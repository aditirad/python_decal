# -*- coding: utf-8 -*-
"""homework9

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-2M1UCPzAf7bAcbA49anRAz14c5b3ZIS
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit
from astropy.table import Table

# 1.1 Read and filter
df = pd.read_csv('GlobalLandTemperaturesByState.csv')
df = df[['dt', 'AverageTemperature', 'State']]
df['dt'] = pd.to_datetime(df['dt'])
df = df[df['dt'].dt.year > 2000]
df = df[df['State'].isin(['Wyoming', 'Nebraska', 'South Dakota'])]
print(df.shape)  # Should be (495, 3)

# 1.2
avg_df = df.groupby('dt')['AverageTemperature'].mean().reset_index()
avg_df.columns = ['date', 'avg_temp']

# 1.3
plt.figure(figsize=(12,5))
plt.plot(avg_df['date'], avg_df['avg_temp'], marker='o', linestyle='-')
plt.xlabel('Date')
plt.ylabel('Average Temperature (°C)')
plt.title('Average Temperature (WY, NE, SD, 2001+)')
plt.show()

# 1.4
avg_df['date_num'] = avg_df['date'].dt.year + avg_df['date'].dt.dayofyear / 365.25

# 1.5
def seasonal_model(x, A, B, C, D):
    return A * np.cos(B * x + C) + D

# Initial guess: amplitude, frequency (2*pi per year), phase, offset
guess = [10, 2*np.pi, 0, avg_df['avg_temp'].mean()]

# 1.6
popt, pcov = curve_fit(seasonal_model, avg_df['date_num'], avg_df['avg_temp'], p0=guess)

# 1.7
plt.figure(figsize=(12,5))
plt.plot(avg_df['date'], avg_df['avg_temp'], 'o', label='Data')
plt.plot(avg_df['date'], seasonal_model(avg_df['date_num'], *popt), 'r-', label='Fit')
plt.xlabel('Date')
plt.ylabel('Average Temperature (°C)')
plt.title('Curve Fit to Average Temperature')
plt.legend()
plt.show()

# 1.8
perr = np.sqrt(np.diag(pcov))
for i, (param, err) in enumerate(zip(popt, perr)):
    print(f"Parameter {i+1}: {param:.3f} ± {err:.3f}")

# 1.9
print(f"Final equation: y = {popt[0]:.3f} * cos({popt[1]:.3f} * x + {popt[2]:.3f}) + {popt[3]:.3f}")

# 1.10
t = Table.read('global CCl4 MM.dat', format='ascii')
df2 = t.to_pandas()
df2.columns = ['date', 'mean', 'sd']

plt.errorbar(df2['date'], df2['mean'], yerr=df2['sd'], fmt='o')
plt.xlabel('Date')
plt.ylabel('Global Mean Concentration')
plt.title('CCl4 Global Mean Concentration')
plt.show()

def lin_model(x, m, b):
    return m * x + b

guess = [0, df2['mean'].mean()]
popt2, pcov2 = curve_fit(lin_model, df2['date'], df2['mean'], sigma=df2['sd'], p0=guess)
perr2 = np.sqrt(np.diag(pcov2))

residuals = df2['mean'] - lin_model(df2['date'], *popt2)
chi2 = np.sum((residuals / df2['sd'])**2)
red_chi2 = chi2 / (len(df2['date']) - len(popt2))

print(f"Slope: {popt2[0]:.4f} ± {perr2[0]:.4f}")
print(f"Intercept: {popt2[1]:.4f} ± {perr2[1]:.4f}")
print(f"Equation: y = {popt2[0]:.4f} * x + {popt2[1]:.4f}")
print(f"Reduced chi-squared: {red_chi2:.2f}")

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit
from astropy.table import Table

# 1.1 Read and filter
df = pd.read_csv('GlobalLandTemperaturesByState.csv')
df = df[['dt', 'AverageTemperature', 'State']]
df['dt'] = pd.to_datetime(df['dt'])
df = df[df['dt'].dt.year > 2000]
df = df[df['State'].isin(['Wyoming', 'Nebraska', 'South Dakota'])]
print(df.shape)  # Should be (495, 3)

# 1.2
avg_df = df.groupby('dt')['AverageTemperature'].mean().reset_index()
avg_df.columns = ['date', 'avg_temp']

# 1.3
plt.figure(figsize=(12,5))
plt.plot(avg_df['date'], avg_df['avg_temp'], marker='o', linestyle='-')
plt.xlabel('Date')
plt.ylabel('Average Temperature (°C)')
plt.title('Average Temperature (WY, NE, SD, 2001+)')
plt.show()

# 1.4
avg_df['date_num'] = avg_df['date'].dt.year + avg_df['date'].dt.dayofyear / 365.25

# 1.5
def seasonal_model(x, A, B, C, D):
    return A * np.cos(B * x + C) + D

# Initial guess: amplitude, frequency (2*pi per year), phase, offset
guess = [10, 2*np.pi, 0, avg_df['avg_temp'].mean()]

# 1.6
popt, pcov = curve_fit(seasonal_model, avg_df['date_num'], avg_df['avg_temp'], p0=guess)


# 1.7
plt.figure(figsize=(12,5))
plt.plot(avg_df['date'], avg_df['avg_temp'], 'o', label='Data')
plt.plot(avg_df['date'], seasonal_model(avg_df['date_num'], *popt), 'r-', label='Fit')
plt.xlabel('Date')
plt.ylabel('Average Temperature (°C)')
plt.title('Curve Fit to Average Temperature')
plt.legend()
plt.show()

# 1.8
perr = np.sqrt(np.diag(pcov))
for i, (param, err) in enumerate(zip(popt, perr)):
    print(f"Parameter {i+1}: {param:.3f} ± {err:.3f}")


# 1.9
print(f"Final equation: y = {popt[0]:.3f} * cos({popt[1]:.3f} * x + {popt[2]:.3f}) + {popt[3]:.3f}")


# 1.10
t = Table.read('global CCl4 MM.dat', format='ascii')
df2 = t.to_pandas()
df2.columns = ['date', 'mean', 'sd']

plt.errorbar(df2['date'], df2['mean'], yerr=df2['sd'], fmt='o')
plt.xlabel('Date')
plt.ylabel('Global Mean Concentration')
plt.title('CCl4 Global Mean Concentration')
plt.show()

def lin_model(x, m, b):
    return m * x + b

guess = [0, df2['mean'].mean()]
popt2, pcov2 = curve_fit(lin_model, df2['date'], df2['mean'], sigma=df2['sd'], p0=guess)
perr2 = np.sqrt(np.diag(pcov2))

residuals = df2['mean'] - lin_model(df2['date'], *popt2)
chi2 = np.sum((residuals / df2['sd'])**2)
red_chi2 = chi2 / (len(df2['date']) - len(popt2))

print(f"Slope: {popt2[0]:.4f} ± {perr2[0]:.4f}")
print(f"Intercept: {popt2[1]:.4f} ± {perr2[1]:.4f}")
print(f"Equation: y = {popt2[0]:.4f} * x + {popt2[1]:.4f}")
print(f"Reduced chi-squared: {red_chi2:.2f}")